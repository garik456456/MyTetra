<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN" "http://www.w3.org/TR/REC-html40/strict.dtd">
<html><head><meta name="qrichtext" content="1" /><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><style type="text/css">
p, li { white-space: pre-wrap; }
</style></head><body style=" font-family:'DejaVu Sans'; font-size:11pt; font-weight:400; font-style:normal;">
<p style=" margin-top:0px; margin-bottom:17px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; background-color:#f9f9f9;"><span style=" font-family:'Georgia,serif'; font-size:14px; color:#555555; background-color:#f9f9f9;">Во-первых, суть cache aware оптимизации не такая уж и сложная - отдавать предпочтение последовательному доступу к данным вместо произвольного доступа. Для проведения этой оптимизации не нужно знать ассемблер и тонкости железа. Более того, ее можно проводить даже на высокоуровневых языках программирования вроде javascript, C#, java.</span></p>
<p style=" margin-top:0px; margin-bottom:17px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; background-color:#f9f9f9;"><span style=" font-family:'Georgia,serif'; font-size:14px; color:#555555; background-color:#f9f9f9;">Во-вторых, cache aware оптимизация дает максимальный выигрыш в производительности на современных архитектурах с иерархическими кэшами по сравнению с другими видами оптимизаций.</span></p>
<p style=" margin-top:0px; margin-bottom:17px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; background-color:#f9f9f9;"><span style=" font-family:'Georgia,serif'; font-size:14px; color:#555555; background-color:#f9f9f9;">Давайте посчитаем разницу в скорости доступа к данным в следующих случаях:</span></p>
<p style=" margin-top:0px; margin-bottom:17px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; background-color:#f9f9f9;"><span style=" font-family:'Georgia,serif'; font-size:14px; color:#555555; background-color:#f9f9f9;">- последовательное обращение к элементам массива;</span></p>
<p style=" margin-top:0px; margin-bottom:17px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; background-color:#f9f9f9;"><span style=" font-family:'Georgia,serif'; font-size:14px; color:#555555; background-color:#f9f9f9;">- произвольное обращение к элементам массива.</span></p>
<p style=" margin-top:0px; margin-bottom:17px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; background-color:#f9f9f9;"><span style=" font-family:'Georgia,serif'; font-size:14px; color:#555555; background-color:#f9f9f9;">Пусть:</span></p>
<p style=" margin-top:0px; margin-bottom:17px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; background-color:#f9f9f9;"><span style=" font-family:'Georgia,serif'; font-size:14px; color:#555555; background-color:#f9f9f9;">- в cache line помещается n элементов массива;</span></p>
<p style=" margin-top:0px; margin-bottom:17px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; background-color:#f9f9f9;"><span style=" font-family:'Georgia,serif'; font-size:14px; color:#555555; background-color:#f9f9f9;">- элемент массива, находящийся в кэше, считывается за Ts с;</span></p>
<p style=" margin-top:0px; margin-bottom:17px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; background-color:#f9f9f9;"><span style=" font-family:'Georgia,serif'; font-size:14px; color:#555555; background-color:#f9f9f9;">- подгрузка новой cache line происходит за m*Ts с.</span></p>
<p style=" margin-top:0px; margin-bottom:17px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; background-color:#f9f9f9;"><span style=" font-family:'Georgia,serif'; font-size:14px; color:#555555; background-color:#f9f9f9;">Тогда N элементов массива при последовательном доступе будут считаны за N*Ts*(1 + m/n) секунд, а при произвольном доступе - за N*Ts*m секунд. Тогда скорость последовательного доступа будет отличаться от скорости произвольного доступа в A = m*n/(m + n) раз. Для современных процессоров m находится в районе 100. Пусть n равно 16. Тогда A = 100*16/116 = 13.8 раз. Даже если n равно 2 (т.е. в cache line помещается хотя бы 2 элемента массива), то скорость последовательного доступа будет больше скорости произвольного доступа в 200/102 = 2 раза. Рассмотрите классический пример - умножение матриц. В теории скорость умножения матриц не зависит от порядка, в котором происходит доступ к элементам матриц. На практике скорость может отличаться в десятки раз. И все из-за кэшей. http://en.wikipedia.org/wiki/Cache-oblivious_algorithm .</span></p>
<p style=" margin-top:0px; margin-bottom:17px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; background-color:#f9f9f9;"><span style=" font-family:'Georgia,serif'; font-size:14px; color:#555555; background-color:#f9f9f9;">Если подняться на один уровень вверх, т.е. в качестве cache line взять блок данных, считываемый/записываемый за раз на жесткий диск (сейчас это 512 байт или 4 Кбайт), то m будет уже в районе миллиона (время произвольного доступа 10 мс, скорость последовательного чтения 100 Мб/с, т.е. за 10 мс можно прочитать 1 Мб последовательных данных).</span></p>
<p style=" margin-top:0px; margin-bottom:17px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; background-color:#f9f9f9;"><span style=" font-family:'Georgia,serif'; font-size:14px; color:#555555; background-color:#f9f9f9;">&gt; В общем случае нужно писать понятный код на языке высокого уровня, который, по возможности, имеет наименьшую сложность. Гнаться за двумя зайцами одновременно не стоит. Я согласен с Макконнеллом в том, что понятность кода важнее его производительности, а &quot;оптимизация&quot; на ровном месте (того, что не является ботлнеком) - вредна.</span></p>
<p style=" margin-top:0px; margin-bottom:17px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; background-color:#f9f9f9;"><span style=" font-family:'Georgia,serif'; font-size:14px; color:#555555; background-color:#f9f9f9;">Полностью согласен. В статье выше про это как бы намекается, когда приводятся примеры, где простые алгоритмы с бОльшей вычислительной сложностью побеждают сложные алгоритмы с меньшей вычислительной сложностью. Нужно было явно упомянуть про вред преждевременной оптимизации в статье - каюсь :)</span></p>
<p style=" margin-top:0px; margin-bottom:17px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; background-color:#f9f9f9;"><span style=" font-family:'Georgia,serif'; font-size:14px; color:#555555; background-color:#f9f9f9;">В то же время знания о работе компиляторов, операционных систем и железа помогают писать более оптимальный код на любом языке программирования и под любую платформу.</span></p>
<p style=" margin-top:0px; margin-bottom:17px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; background-color:#f9f9f9;"><span style=" font-family:'Georgia,serif'; font-size:14px; color:#555555; background-color:#f9f9f9;">&gt; Что-то вроде - было так, работало медленно, разобрались, сделали так, стало работать быстро</span></p>
<p style=" margin-top:0px; margin-bottom:17px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; background-color:#f9f9f9;"><span style=" font-family:'Georgia,serif'; font-size:14px; color:#555555; background-color:#f9f9f9;">Я как то переписал обычный hash table в варианте linear probing[1] на cuckoo hashing[2][3] в двух вариантах, 1) четыре хэш функции, одна ячейка в корзине; 2) две хэш функции, четыре ячейки в корзине. Так вот, потребление памяти, как и ожидалось снизилось значительно, примерно в два раза. Это одно из ключевых свойств алгоритма cuckoo hashing. Но вместе с тем, на больших объемах данных (1500000 уникальных объектов) значительно упала скорость поиска элементов, примерно в 3-4 раза. Это при том, что алгоритм гарантирует константное максимальное количество сравнений. Замедление не связано с расчетом дополнительных хэш-кодов, они были просчитаны заранее. Единственное возможное объяснение - непопадание данных в кэш, ведь cuckoo hashing разбрасывает элементы по ячейкам, которые могут отставать друг от друга на значительное расстояние.</span></p>
<p style=" margin-top:0px; margin-bottom:17px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; background-color:#f9f9f9;"><span style=" font-family:'Georgia,serif'; font-size:14px; color:#555555; background-color:#f9f9f9;">На эту тему есть публикация How Caching Affects Hashing[4], в которой сравнивается производительность разных реализаций хэш таблиц на разных объемах данных. У них там результаты подтверждают мои наблюдения для большого количества маленьких элементов. Но вместе с тем авторы делают вывод, что на малых объемах данных или для больших элементов double hashing предпочтительнее, чем linear probing.</span></p>
<p style=" margin-top:0px; margin-bottom:17px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; background-color:#f9f9f9;"><span style=" font-family:'Georgia,serif'; font-size:14px; color:#555555; background-color:#f9f9f9;">[1] http://en.wikipedia.org/wiki/Linear_probing</span></p>
<p style=" margin-top:0px; margin-bottom:17px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; background-color:#f9f9f9;"><span style=" font-family:'Georgia,serif'; font-size:14px; color:#555555; background-color:#f9f9f9;">[2] http://en.wikipedia.org/wiki/Cuckoo_hashing</span></p>
<p style=" margin-top:0px; margin-bottom:17px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; background-color:#f9f9f9;"><span style=" font-family:'Georgia,serif'; font-size:14px; color:#555555; background-color:#f9f9f9;">[3] http://www.ru.is/faculty/ulfar/CuckooHash.pdf</span></p>
<p style=" margin-top:0px; margin-bottom:17px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; background-color:#f9f9f9;"><span style=" font-family:'Georgia,serif'; font-size:14px; color:#555555; background-color:#f9f9f9;">[4] http://www.siam.org/meetings/alenex05/papers/13gheileman.pdf</span></p>
<p style=" margin-top:0px; margin-bottom:17px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; background-color:#f9f9f9;"><span style=" font-family:'Georgia,serif'; font-size:14px; color:#555555; background-color:#f9f9f9;">А вообще, вот САМЫЙ яркий пример того, как удалось увеличить производительность алгоритма удаления устаревших записей в кэше Varnish ( http://en.wikipedia.org/wiki/Varnish_(software) ) до 10 раз путем модификации стандартной структуры данных heap ( http://en.wikipedia.org/wiki/Heap_(data_structure)).</span></p>
<p style=" margin-top:0px; margin-bottom:17px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; background-color:#f9f9f9;"><span style=" font-family:'Georgia,serif'; font-size:14px; color:#555555; background-color:#f9f9f9;">http://queue.acm.org/detail.cfm?id=1814327</span></p>
<p style=" margin-top:0px; margin-bottom:17px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; background-color:#f9f9f9;"><span style=" font-family:'Georgia,serif'; font-size:14px; color:#555555; background-color:#f9f9f9;">В теории эта модификация должна была уменьшить скорость алгоритма, но на практике это справедливо только для маленьких размеров кэша. Для больших размеров кэша, когда операционная система начинает вытеснять редко используемые части кэша в своп, скорость возрастает до 10 раз. Т.к. типичный сценарий использования varnish подразумевает большой размер кэша, эта модификация дала существенный прирост скорости на практике.</span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:17px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; font-family:'Georgia,serif'; font-size:14px; color:#555555; background-color:#f9f9f9;"><br /></p>
<p style=" margin-top:0px; margin-bottom:17px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; background-color:#f9f9f9;"><span style=" font-family:'Georgia,serif'; font-size:14px; color:#555555; background-color:#f9f9f9;">В догонку - можно самостоятельно изучить следующие связанные темы, вот список провокационных вопросов для этого:</span></p>
<p style=" margin-top:0px; margin-bottom:17px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; background-color:#f9f9f9;"><span style=" font-family:'Georgia,serif'; font-size:14px; color:#555555; background-color:#f9f9f9;">- почему http://en.wikipedia.org/wiki/Unrolled_linked_list быстрее обычного http://en.wikipedia.org/wiki/Linked_list ?</span></p>
<p style=" margin-top:0px; margin-bottom:17px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; background-color:#f9f9f9;"><span style=" font-family:'Georgia,serif'; font-size:14px; color:#555555; background-color:#f9f9f9;">- почему в базах данных и файловых системах предпочитают использовать http://en.wikipedia.org/wiki/B-tree вместо остальных видов binary search tree?</span></p>
<p style=" margin-top:0px; margin-bottom:17px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; background-color:#f9f9f9;"><span style=" font-family:'Georgia,serif'; font-size:14px; color:#555555; background-color:#f9f9f9;">- почему http://en.wikipedia.org/wiki/Merge_sort быстрее других видов сортировки для больших объемов данных?</span></p>
<p style=" margin-top:0px; margin-bottom:17px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; background-color:#f9f9f9;"><span style=" font-family:'Georgia,serif'; font-size:14px; color:#555555; background-color:#f9f9f9;">- почему для сортировки маленьких объемов данных используют http://en.wikipedia.org/wiki/Insertion_sort ? Например, см. http://en.wikipedia.org/wiki/Quicksort#Optimizations .</span></p>
<p style=" margin-top:0px; margin-bottom:17px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; background-color:#f9f9f9;"><span style=" font-family:'Georgia,serif'; font-size:14px; color:#555555; background-color:#f9f9f9;">- почему СУБД предпочитают использовать full table scan ( http://en.wikipedia.org/wiki/Full_table_scan ) вместо поиска по индексу для таблиц с небольшим количеством записей?</span></p>
<p style=" margin-top:0px; margin-bottom:17px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; background-color:#f9f9f9;"><span style=" font-family:'Georgia,serif'; font-size:14px; color:#555555; background-color:#f9f9f9;">Тут ещё много чего по теме написать можно - но сил нету всё это набивать.</span></p></body></html>